# 1.2 Data Ownership Boundaries

## Overview

This document defines which service owns which data tables, how shared data is accessed across service boundaries, and what migration strategy applies to each table.

---

## Auth Service — Owned Data

### `users` table (full ownership)

| Column                    | Type     | Notes                        |
| ------------------------- | -------- | ---------------------------- |
| `id`                      | Integer  | PK, auto-increment           |
| `username`                | String   | Unique, indexed              |
| `display_name`            | String   | Nullable                     |
| `password_hash`           | String   | bcrypt or SHA-256 (legacy)   |
| `status`                  | String   | Default `"online"`           |
| `profile_picture_url`     | String   | Nullable                     |
| `display_name_updated_at` | DateTime | Nullable                     |
| `created_at`              | DateTime | Default `now()`              |
| `updated_at`              | DateTime | Default `now()`, auto-update |

**Write access**: Auth Service only (register, login, profile update).
**Read access**: All services need user info (channels, game, media, AI). After extraction, other services will call Auth Service API (`GET /auth/users/{id}`, `GET /auth/me`) instead of querying the table directly.

### `memberships` table (owned by Chat/Channel Service) ✅ DECOUPLED

| Column       | Type     | Notes                            |
| ------------ | -------- | -------------------------------- |
| `user_id`    | Integer  | FK → `users.id`, composite PK    |
| `channel_id` | Integer  | FK → `channels.id`, composite PK |
| `joined_at`  | DateTime | Default `now()`                  |

**Previous state**: Auth wrote memberships during register/login (auto-join #general).
**Current state**: ✅ **DECOUPLED** - Auth no longer writes memberships. Instead:
- Auth publishes `user.registered` event via Redis pub/sub
- Channel Service (monolith) subscribes and creates membership
- This removes cross-domain coupling and enables Auth Service extraction

**Implementation**: See TD-3 remediation for details on Redis pub/sub decoupling.

---

## Auth Service — Read-Only Dependencies

### `channels` table (owned by Chat/Channel Service)

Auth currently queries `channels` to find/create `#general` during register and login. This is a cross-domain write that must be decoupled.

**Migration strategy**: Remove #general auto-join from Auth Service. Either:

1. Emit a `user.registered` / `user.logged_in` event that the Channel Service consumes to auto-join.
2. Move the auto-join logic to a post-registration hook in the monolith.

---

## AI Service — Owned Data

### No persistent data tables

The AI Service does not own any database tables. It is stateless except for:

1. **In-memory rate-limit store** (`_rate_limit_store` dict in [`ai.py`](backend/src/api/endpoints/ai.py:24)) — keyed by `user_id`, stores timestamps of recent requests.
2. **Anthropic API state** — the `AgentOrchestrator` singleton holds an `httpx.AsyncClient` instance.

**Target state**: Rate-limit data moves to Redis (shared, distributed). No database tables needed for AI Service.

---

## AI Service — Read-Only Dependencies

### `users` table (owned by Auth Service)

AI uses `current_user.id` for rate limiting and `current_user` for authentication. After extraction, AI Service will:

1. Validate JWT tokens independently (shared secret or public key verification).
2. Extract `user_id` from the JWT payload — no direct DB query needed.

---

## Data Boundary Summary

| Table            | Current Owner | Target Owner | Auth Service Access | AI Service Access | Migration Action                          | Status |
| ---------------- | ------------- | ------------ | ------------------- | ----------------- | ----------------------------------------- | ------ |
| `users`          | Monolith      | Auth Service | Read/Write (full)   | Read (via JWT)    | Move to Auth Service PostgreSQL           | Pending |
| `channels`       | Monolith      | Chat Service | None (decoupled)    | None              | ✅ Removed auth's channel writes          | **DONE** |
| `memberships`    | Monolith      | Chat Service | None (decoupled)    | None              | ✅ Removed auth's membership writes       | **DONE** |
| `messages`       | Monolith      | Chat Service | None                | None              | No change                                 | N/A |
| `game_states`    | Monolith      | Game Service | None                | None              | No change                                 | N/A |
| `game_sessions`  | Monolith      | Game Service | None                | None              | No change                                 | N/A |
| Rate-limit store | In-memory     | Redis        | None                | Read/Write        | Replace dict with Redis sorted set        | **TD-6** |

---

## Cross-Service Data Access Patterns (Post-Migration)

### Pattern 1: Auth → Other Services (user info)

Other services need user data (username, display_name, profile_picture_url). Options:

- **Option A (API call)**: Services call `GET /auth/users/{id}`. Simple but adds latency.
- **Option B (JWT claims)**: Embed essential user info in JWT claims. No API call needed for basic info.
- **Option C (Redis cache)**: Cache user profiles in Redis with TTL. Best for frequently accessed data. ✅

**Recommendation**: Use Redis cache for user profile data (Option C). Auth Service writes/invalidates cache entries on profile changes. Other services read from Redis with fallback to Auth API.

### Pattern 2: AI → Auth (authentication)

AI Service needs to verify JWT tokens. Options:

- **Option A (shared secret)**: Both services share `SECRET_KEY`. AI decodes JWT locally.
- **Option B (auth endpoint)**: AI calls `GET /auth/me` to validate tokens (like media-storage does today).
- **Option C (public key)**: Switch to RS256 asymmetric JWT. Auth signs, all services verify with public key.

**Recommendation**: Start with Option A (shared secret) for simplicity. Migrate to Option C when adding more services.

### Pattern 3: Registration → Channel auto-join ✅ IMPLEMENTED

**Status**: Implemented using Option A (Redis pub/sub event)

**Implementation**:

- **Event**: `user.registered` published via Redis pub/sub
- **Channel**: Single `user.events` Redis channel
- **Payload**: `{event_type: "user.registered", user_id: int, username: str, timestamp: str}`
- **Scope**: Only registration emits events (not login, to avoid duplicate joins)
- **Subscriber**: Background thread in monolith handles auto-join
- **Idempotent**: Safe to receive same event multiple times

**Design Decisions**:

1. **Fire-and-forget**: Registration succeeds even if Redis is unavailable
2. **Single channel**: Using `user.events` with event_type discrimination (simpler than multiple channels)
3. **No login events**: Only register triggers auto-join (login assumes user already joined)
4. **Throwaway audit logger**: Separate microservice for testing strangle pattern

**Files**:
- Publisher: `backend/src/services/event_publisher.py`
- Subscriber: `backend/src/services/event_subscriber.py`

---

## Database Migration Strategy

### Current: SQLite (single file `chat.db`)

All tables live in one SQLite database. No connection pooling, no concurrent write support.

### Target: PostgreSQL (Kubernetes pod)

- **Auth Service**: Owns a dedicated PostgreSQL database with `users` table only.
- **Monolith**: Continues using SQLite (or migrates to PostgreSQL) for `channels`, `memberships`, `messages`, `game_*` tables.
- **AI Service**: No database. Uses Redis for rate limiting.

### Migration steps:

1. Deploy PostgreSQL pod in K3s.
2. Create `auth_db` database with `users` schema.
3. Migrate existing user data from SQLite to PostgreSQL.
4. Update Auth Service `DATABASE_URL` to point to PostgreSQL.
5. Remove `users` table dependency from monolith (use Auth API instead).
