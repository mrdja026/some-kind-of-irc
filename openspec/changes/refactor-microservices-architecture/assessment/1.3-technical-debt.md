# 1.3 Technical Debt in Auth & AI Domains

## Auth Service Technical Debt

### TD-1: Dual Password Hashing (Critical)

**Location**: [`verify_password()`](backend/src/api/endpoints/auth.py:49) and [`get_password_hash()`](backend/src/api/endpoints/auth.py:62)

**Problem**: The system supports two hashing schemes simultaneously:

1. **bcrypt** (primary) — via `passlib.CryptContext`
2. **SHA-256** (fallback) — via `hashlib.sha256`

The `verify_password()` function detects SHA-256 hashes by checking if the stored hash is exactly 64 hex characters, then falls back to bcrypt. The `get_password_hash()` function catches bcrypt exceptions and falls back to SHA-256.

**Risks**:

- SHA-256 is **not suitable for password hashing** (no salt, no work factor, vulnerable to rainbow tables)
- The 64-char hex detection heuristic is fragile
- bcrypt's 72-byte password limit is handled by silent truncation, with SHA-256 as fallback for failures
- Debug `print()` statements in [`authenticate_user()`](backend/src/api/endpoints/auth.py:77) leak password hash info to stdout — **must remove**

**Remediation**:

1. Migrate all SHA-256 hashes to bcrypt on next login (re-hash after successful verification)
2. Remove SHA-256 fallback path entirely after migration period
3. Use `argon2` instead of bcrypt to avoid the 72-byte limit (or keep bcrypt with documented truncation)
4. Remove all `print()` debug statements from auth code

**Effort**: Medium (requires data migration + code change)

---

### TD-2: No CSRF Protection

**Location**: [`register()`](backend/src/api/endpoints/auth.py:137) and [`login()`](backend/src/api/endpoints/auth.py:178)

**Problem**: JWT is stored as an HttpOnly cookie with `secure=False` and `samesite="lax"`. No CSRF token is used.

**Risks**:

- `secure=False` means cookies are sent over HTTP (acceptable for local dev, not production)
- `samesite="lax"` provides partial CSRF protection but not complete
- No explicit CSRF token validation

**Remediation**:

1. Set `secure=True` in production (behind HTTPS via NGINX Ingress)
2. Switch to `samesite="strict"`; fall back to `samesite="lax"` if strict causes issues
3. Consider moving to Authorization header-based JWT for API calls (keep cookie for SSR)

**Effort**: Low

---

### TD-3: Cross-Domain Coupling (#general auto-join) ✅ COMPLETED

**Status**: **COMPLETED** - Implemented using Redis pub/sub

**Location**: 
- Publisher: [`backend/src/services/event_publisher.py`](backend/src/services/event_publisher.py)
- Subscriber: [`backend/src/services/event_subscriber.py`](backend/src/services/event_subscriber.py)

**Problem**: Both register and login endpoints query/create the `#general` channel and create `Membership` records. This couples auth to the channel domain.

**Solution Implemented**:

1. ✅ Extracted #general auto-join into separate function/event
2. ✅ Using Redis pub/sub event (`user.registered`) for loose coupling
3. ✅ Channel Service (monolith) subscribes and handles auto-join via background thread

**Implementation Details**:

- **Event**: `user.events` channel with `event_type: "user.registered"`
- **Publisher**: Auth service publishes event after successful registration
- **Subscriber**: Background thread in monolith subscribes to events
- **Scope**: Only `register()` emits events (not login, per decision to avoid duplicate joins)
- **Fire-and-forget**: Registration succeeds even if Redis is unavailable
- **Idempotent**: Safe to handle same event multiple times

**Effort**: Medium ✅ **COMPLETED**

---

### TD-4: No Input Validation on Username

**Location**: [`UserCreate`](backend/src/api/endpoints/auth.py:25) model

**Problem**: `UserCreate` only requires `username: str` and `password: str` with no validation rules.

**Risks**:

- Empty usernames, whitespace-only usernames, or extremely long usernames are accepted
- No character restrictions (special chars, SQL injection via ORM is safe but display issues possible)
- No minimum password length or complexity requirements

**Remediation**:

1. Add Pydantic validators for username (min/max length, allowed characters)
2. Add password strength requirements (min length, complexity)

**Effort**: Low

---

### TD-5: Admin Allowlist Enforcement ✅ COMPLETED

**Status**: **COMPLETED** - Implemented in `backend/src/core/admin.py`

**Location**: 
- Config: [`backend/src/core/config.py`](backend/src/core/config.py) - `ADMIN_ALLOWLIST` setting
- Implementation: [`backend/src/core/admin.py`](backend/src/core/admin.py) - `require_admin` dependency
- Applied to: [`backend/src/api/endpoints/ai.py`](backend/src/api/endpoints/ai.py) and [`backend/src/api/endpoints/data_processor.py`](backend/src/api/endpoints/data_processor.py)

**Implementation Details**:

1. **Format**: Semicolon-separated usernames (e.g., `alice;bob;charlie`)
2. **Case handling**: Case-insensitive (Alice, alice, ALICE all match)
3. **Default behavior**: If empty, defaults to `admina` user
4. **Failure response**: HTTP 404 (security through obscurity)
5. **Scope**: AI endpoints (`/ai/*`) and data-processor endpoints (`/data-processor/*`)
6. **Caching**: Allowlist parsed once and cached using `@lru_cache` for performance

**Helm Configuration**:
```yaml
config:
  adminAllowlist: "alice;bob;admina"
```

**Risks Addressed**:

- ✅ Access control for AI features implemented
- ✅ Admin-only access enforced for sensitive operations
- ✅ Easy to manage via Helm values

**Effort**: Low-Medium ✅ **COMPLETED**

---

## Game Service Technical Debt

### TD-12: NPC Seeding on Every auth_game Call

**Location**: [`auth_game`](backend/src/api/endpoints/auth.py)

**Problem**: Every call to `auth_game` seeds 4 NPC users unconditionally. This inflates the player list and persists extra users/sessions across runs.

**Risks**:

- Game snapshots become noisy and harder to debug
- Accumulated NPC users/sessions increase database size
- Player counts appear inconsistent between runs

**Remediation**:

1. Seed NPCs only when the #game channel is empty, or
2. Add a `seed_npcs=false` flag to `auth_game` and default it off for tests

**Effort**: Low

---

## AI Service Technical Debt

### TD-6: Redis Rate Limiting (Critical) — COMPLETED

**Location**: [`backend/src/services/rate_limiter.py`](backend/src/services/rate_limiter.py) with enforcement in [`backend/src/api/endpoints/ai.py`](backend/src/api/endpoints/ai.py) and [`backend/src/api/endpoints/data_processor.py`](backend/src/api/endpoints/data_processor.py)

**Problem**: Rate limiting previously used a module-level Python dict (`dict[int, list[datetime]]`), which was not distributed or durable.

**Solution Implemented**:

1. Added shared Redis client (`backend/src/services/rate_limiter.py`) using sorted-set sliding window.
2. `enforce_rate_limit()` now guards all `/ai/*` and `/data-processor/*` endpoints with a 10 requests/hour window (configurable).
3. Keys auto-expire (TTL=3600s) and cleanup uses `ZREMRANGEBYSCORE`; retry window is calculated from oldest timestamp.
4. Fail-open behavior if Redis is unavailable to avoid hard outages.

**Files**:
- `backend/src/services/rate_limiter.py`
- `backend/src/api/endpoints/ai.py`
- `backend/src/api/endpoints/data_processor.py`
- `k8s/manifests/monolith.yaml` (adds `REDIS_URL`, `AI_RATE_LIMIT_PER_HOUR`)
- `k8s/helm/irc-app/values.yaml` and `templates/configmap.yaml` (surfaced config)

**Status**: ✅ COMPLETED

---

### TD-7: No API Key Rotation

**Location**: [`Settings.ANTHROPIC_API_KEY`](backend/src/core/config.py:14)

**Problem**: Single static API key configured via environment variable. No rotation mechanism.

**Risks**:

- If the key is compromised, manual intervention required to rotate
- No audit trail of key usage
- No support for multiple keys or gradual rotation

**Remediation**:

1. Support multiple API keys (primary + fallback)
2. Implement key rotation via Kubernetes Secrets + Argo CD sync
3. Add key usage logging/metrics

**Effort**: Medium

---

### TD-8: No Error Categorization

**Location**: [`query_ai_agents()`](backend/src/api/endpoints/ai.py:98) and [`query_ai_agents_stream()`](backend/src/api/endpoints/ai.py:136)

**Problem**: All Anthropic API errors are caught as generic `Exception` and returned as 500. No distinction between:

- Rate limit errors from Anthropic (429)
- Authentication errors (401)
- Model overload (529)
- Network timeouts

**Risks**:

- Users see generic "AI processing failed" for all error types
- No retry logic for transient errors
- No circuit breaker for sustained failures

**Remediation**:

1. Catch `httpx.HTTPStatusError` and map Anthropic status codes to appropriate responses
2. Implement circuit breaker pattern (e.g., using `circuitbreaker` library or custom)
3. Add retry with exponential backoff for transient errors

**Effort**: Medium

---

### TD-9: Hardcoded Agent Instructions

**Location**: [`AgentOrchestrator.process_query()`](backend/src/services/agent_orchestrator.py:108) and [`stream_judge_response()`](backend/src/services/agent_orchestrator.py:187)

**Problem**: Agent system prompts are duplicated between `process_query()` and `stream_judge_response()`. The instructions are hardcoded strings, not configurable.

**Risks**:

- Changing agent behavior requires code deployment
- Duplicated prompt strings can drift out of sync
- No A/B testing or prompt versioning

**Remediation**:

1. Extract prompts to a shared constant or config file
2. Consider storing prompts in a database or config map for runtime updates
3. Deduplicate the specialist-agent logic between the two methods

**Effort**: Low

---

### TD-10: `datetime.utcnow()` Deprecation

**Location**: [`check_rate_limit()`](backend/src/api/endpoints/ai.py:47) and [`get_remaining_requests()`](backend/src/api/endpoints/ai.py:69)

**Problem**: Uses `datetime.utcnow()` which is deprecated in Python 3.12+ in favor of `datetime.now(timezone.utc)`.

**Risks**:

- Deprecation warnings in Python 3.12+
- Potential timezone-naive datetime comparison bugs

**Remediation**:

1. Replace `datetime.utcnow()` with `datetime.now(timezone.utc)` throughout

**Effort**: Trivial

---

### TD-11: Argo CD UI Unreachable Without Port-Forward

**Location**: `argocd` namespace (Argo CD server service)

**Problem**: Argo CD is not exposed; the UI/API only works after manual port-forwarding.

**Risks**:

- GitOps sync and drift detection are effectively disabled unless someone runs the port-forward
- Onboarding friction; no shared URL for reviewers
- Higher chance of divergent cluster state because changes are applied manually

**Remediation**:

1. Add ingress or service exposure for `argocd-server`; until fixed, run:
   ```sh
   kubectl port-forward -n argocd svc/argocd-server 8080:443
   ```
2. Re-enable Argo CD sync and RBAC-backed login

**Effort**: Low-Medium

---

## Summary Table

| ID    | Domain | Severity | Description                              | Effort  | Status |
| ----- | ------ | -------- | ---------------------------------------- | ------- | ------ |
| TD-1  | Auth   | Critical | Dual password hashing (SHA-256 fallback) | Medium  | ✅ **COMPLETED** |
| TD-2  | Auth   | Medium   | No CSRF protection                       | Low     | Pending |
| TD-3  | Auth   | Medium   | Cross-domain coupling (#general)         | Medium  | ✅ **COMPLETED** |
| TD-4  | Auth   | Low      | No input validation on username          | Low     | Pending |
| TD-5  | Auth   | High     | Admin allowlist enforcement              | Low-Med | ✅ **COMPLETED** |
| TD-6  | AI     | Critical | Redis-backed rate limiting               | Medium  | ✅ **COMPLETED** |
| TD-7  | AI     | Medium   | No API key rotation                      | Medium  | Pending |
| TD-8  | AI     | Medium   | No error categorization                  | Medium  | Pending |
| TD-9  | AI     | Low      | Hardcoded/duplicated agent prompts       | Low     | Pending |
| TD-10 | AI     | Low      | Deprecated `datetime.utcnow()`           | Trivial | Pending |
| TD-11 | Infra  | Medium   | Argo CD UI unreachable without port-forward | Low-Med | Pending |
| TD-12 | Game   | Low      | NPC seeding on every auth_game call      | Low     | Pending |

## Migration Priority

### ✅ COMPLETED (Ready for Auth Service Extraction)

1. **TD-1** ✅ — Standardize on bcrypt, remove SHA-256 fallback
2. **TD-3** ✅ — Decouple #general auto-join from auth using Redis pub/sub
3. **TD-5** ✅ — Implement ADMIN_ALLOWLIST enforcement for AI and data-processor access

### Must Address Before AI Service Extraction

4. **TD-6** — Replace in-memory rate limiting with Redis ✅

### Should Address (Can Follow)

5. **TD-7** — API key rotation via K8s Secrets
6. **TD-8** — Error categorization and circuit breakers
7. **TD-2** — CSRF protection (production hardening)

### Nice to Have

8. **TD-4** — Input validation improvements
9. **TD-9** — Prompt deduplication
10. **TD-10** — datetime deprecation fix
11. **TD-11** — Expose Argo CD (remove manual port-forward dependency)
12. **TD-12** — Seed NPCs only when #game is empty or behind a flag

---

## K3s Deployment Status (Post-Blocker Fix)

### Completed ✅
- K3s Strangler Cutover: hello-world removed, real `ai-service` + `data-processor` deployed
- Frontend SSR deployed in K3s on port 4269
- Admin allowlist enforced on `/ai/*` and `/data-processor/*` (JWT cookie + 404)
- Shared ConfigMap + Secret for all services
- CORS updated for `http://localhost:4269` origin
- Seeded users: `admina` (admin), `guest`, `guest2`, `guest3`, `guest4` (non-admin)
- `create_test_user.py` fixed: `hash_type="bcrypt"` now set (was causing 401 on login)

### Known Issues (Blocking Testing)

#### IMAGE-1: Image Upload Does Not Work in K3s (Critical)
- **Root cause**: `minio` and `media-storage` services are not deployed in K3s — only in Docker Compose
- **Impact**: All image upload/display features broken; monolith's `MEDIA_STORAGE_URL=http://media-storage:9101` returns connection refused
- **Fix needed**: Create `k8s/manifests/minio.yaml` and `k8s/manifests/media-storage.yaml` (Deployment + Service + PVC)
- **Workaround**: Use Docker Compose (`docker-compose up`) for testing image features

#### BUG-2: Frontend WebSocket targets localhost; multi-user chat breaks (Critical)
- **Symptom**: Only one user can chat; console shows `React error #418 (HTML)` and `Firefox can’t establish a connection to the server at ws://localhost/ws/4` with WebSocket error stack in `main-BY5aWxki.js`.
- **Likely cause**: Build-time `VITE_PUBLIC_WS_URL` (and related env) set to `ws://localhost/ws`, so SSR bundle/hydration assumes localhost; remote users cannot open the socket, causing hydration mismatch.
- **Impact**: Real-time chat fails for remote clients; only the host machine sees updates.
- **Fix needed**: Set `VITE_PUBLIC_WS_URL` to the ingress host (e.g., `ws://46.225.9.4/ws` or the configured domain) before building the frontend image and redeploy; verify hydration with non-minified dev build if errors persist.

#### DP-1: Data Processor Cannot Be Tested End-to-End
- **Root cause**: Data processor depends on MinIO for document storage (`MINIO_ENDPOINT`), which isn't deployed in K3s
- **Impact**: Document upload, OCR, and template matching features are inaccessible even for admin users
- **Dependency**: Must resolve IMAGE-1 first (deploy MinIO in K3s)
- **Additional**: `FEATURE_DATA_PROCESSOR` flag needs to be set in monolith for proxy endpoints to work

---

## REOPENED
**mention this when asked about future plans and potential blocker**

### Infrastructure Gaps
- [ ] Deploy MinIO in K3s (blocks IMAGE-1 and DP-1)
- [ ] Deploy media-storage service in K3s (blocks IMAGE-1)
- [ ] Set `FEATURE_DATA_PROCESSOR=true` in monolith config for proxy endpoints
- [ ] Create frontend for that or check the current status
### What to checking
- [ ] Check the #game channel
- [ ] Do a ddx on the Solution
- [ ] fix the documentation, extract it from specs and scripts for teardown and run_localy_k3s.sh

### Platform Support
- [ ] REVISIT LOCAL FOR WINDOWS — K3s scripts are Linux-only; need Windows alternative (Docker Desktop + K8s?)
- [ ] REVISIT LOCAL ONLY FRONTEND — Frontend can run locally via `pnpm dev` pointing at K3s backend
- [ ] REVISIT SETUP FOR LINUX — Current scripts target Ubuntu LTS; document other distros

### Branching
- [x] BRANCHES — `giga-vibe` becomes main after validation - done

# BIG BUG-2
 -[ ] only guest2 was able to chat? the rest had their join channel disabled 

### Bug Fixes Applied

- [x] `create_test_user.py` — Added `hash_type="bcrypt"` (was `None`, caused login 401)
- [x] CORS — Added `http://localhost:4269` to `ALLOWED_ORIGINS` in ConfigMap
